//! Generate schema.generated.rs

use std::collections::HashMap;

use convert_case::{Case, Casing};
use csv::ReaderBuilder;
use flb_schema::config::{FlbConfigSchema, FlbPlugin};
use once_cell::sync::Lazy;
use serde::Deserialize;
use xshell::{cmd, Shell};

use crate::{codegen::ensure_file_contents, project_root};

const FLB_SCHEMA_DEFAULT_VERSION: &str = "3.1.5";
const FLB_SCHEMA_URL_TEMPLATE: &str =
    "https://packages.fluentbit.io/{version}/fluent-bit-schema-{version}.json";

#[derive(Debug, Hash, PartialEq, Eq)]
struct PluginKey {
    section_type: String,
    plugin_name: String,
}

impl PluginKey {
    fn new(section_type: String, plugin_name: String) -> Self {
        Self {
            section_type,
            plugin_name,
        }
    }
}

/// ex. <("input", "netif"), ("Network I/O Log Based Metrics", "network-io-metrics")>
#[derive(Debug, Default, Clone, PartialEq, Eq)]
struct PluginInfo {
    /// Since label in the fluent-bit source code is not really user-friendly, use the name in the docs
    /// ex. "Input plugin for Splunk HEC payloads" -> "Splunk"
    label_in_docs: String,
    doc_path: String,
}

#[derive(Deserialize)]
struct CsvRow {
    section_type: String,
    plugin_name: String,
    label_in_docs: String,
    doc_path: String,
}

/// <(section_type, plugin_name), doc_path>
/// ex. <("input", "netif"), "network-io-metrics">
static PLUGIN_INFO_MAP: Lazy<HashMap<PluginKey, PluginInfo>> = Lazy::new(|| {
    let mut map = HashMap::new();

    // map.insert(
    //     PluginKey::new("input", "collectd"),
    //     PluginInfo::new("Collectd", "collectd"),
    // );
    // map.insert(
    //     PluginKey::new("input", "cpu"),
    //     PluginInfo::new("CPU Log Based Metrics", "cpu-metrics"),
    // );
    // map.insert(
    //     PluginKey::new("input", "netif"),
    //     PluginInfo::new("Network I/O Log Based Metrics", "network-io-metrics"),
    // );

    // let mut file = File::open("assets/plugin_info.csv").unwrap();
    // let mut contents = String::new();
    // file.read_to_string(&mut contents).unwrap();

    let contents = include_str!("assets/plugin_info.csv");

    let mut reader = ReaderBuilder::new().from_reader(contents.as_bytes());
    for result in reader.deserialize::<CsvRow>() {
        let record = result.unwrap();
        let plugin_key = PluginKey {
            section_type: record.section_type,
            plugin_name: record.plugin_name,
        };
        let plugin_info = PluginInfo {
            label_in_docs: record.label_in_docs,
            doc_path: record.doc_path,
        };
        map.insert(plugin_key, plugin_info);
    }

    // for result in reader.records() {
    //     let record = result.unwrap();
    //     let plugin_key = PluginKey {
    //         section_type: &record[0],
    //         plugin_name: record[1].to_string(),
    //     };
    //     let plugin_info = PluginInfo {
    //         label_in_docs: record[2].to_string(),
    //         doc_path: record[3].to_string(),
    //     };
    //     map.insert(plugin_key, plugin_info);
    // }

    map
});

pub fn generate(sh: &Shell, flb_version: Option<String>) -> anyhow::Result<()> {
    let flb_version = flb_version.unwrap_or_else(|| FLB_SCHEMA_DEFAULT_VERSION.to_owned());
    let url = FLB_SCHEMA_URL_TEMPLATE.replace("{version}", &flb_version);

    // TODO; maybe cache this?
    let schema_json = cmd!(sh, "curl {url}").read()?;
    let parsed: FlbConfigSchema = serde_json::from_str(&schema_json)?;

    let generated = generate0(&parsed);

    let path = project_root().join("fluent-bit-language-server/src/schema.generated.rs");
    let generated = add_preamble(&flb_version, generated);

    ensure_file_contents(path.as_path(), &generated, false);

    Ok(())
}

fn add_preamble(flb_version: &str, mut text: String) -> String {
    let preamble = format!(
        r#"/// Generated by `cargo xtask schema` (fluent-bit version: {flb_version})
/// Don't modify this file manually.
"#
    );
    text.insert_str(0, &preamble);
    text
}

// TODO: something better than this?
fn generate0(schema: &FlbConfigSchema) -> String {
    let mut res = String::new();

    res.push_str(
        r#"
#[rustfmt::skip::macros(add_snippet)]
pub static FLB_DATA: Lazy<FlbData> = Lazy::new(|| {
    let mut data = FlbData::new();
"#,
    );

    // TODO: add docs for undocumented ones?
    let ignored = [
        "event_type",
        "lib",
        // filter
        "alter_size",
        // output
        "exit",
        "plot",
        "udp",
    ];

    //customs
    res.push_str("\n//// Customs\n");
    for plugin in schema.customs.iter() {
        if ignored.contains(&plugin.name.as_str()) {
            println!("Ignoring custom plugin: {}", plugin.name);
            continue;
        }
        res.push_str(
            &plugin_stub(plugin).unwrap_or_else(|| panic!("Plugin stub not found: {:?}", plugin)),
        );
    }

    res.push_str("\n//// Input\n");
    for plugin in schema.inputs.iter() {
        // res.push_str(&plugin_stub(plugin));
        if ignored.contains(&plugin.name.as_str()) {
            println!("Ignoring input plugin: {}", plugin.name);
            continue;
        }
        res.push_str(
            &plugin_stub(plugin).unwrap_or_else(|| panic!("Plugin stub not found: {:?}", plugin)),
        );
    }

    res.push_str("\n//// Filter\n");
    for plugin in schema.filters.iter() {
        // res.push_str(&plugin_stub(plugin));
        if ignored.contains(&plugin.name.as_str()) {
            println!("Ignoring filter plugin: {}", plugin.name);
            continue;
        }
        res.push_str(
            &plugin_stub(plugin).unwrap_or_else(|| panic!("Plugin stub not found: {:?}", plugin)),
        );
    }

    res.push_str("\n//// Output\n");
    for plugin in schema.outputs.iter() {
        // res.push_str(&plugin_stub(plugin));
        if ignored.contains(&plugin.name.as_str()) {
            println!("Ignoring output plugin: {}", plugin.name);
            continue;
        }
        res.push_str(
            &plugin_stub(plugin).unwrap_or_else(|| panic!("Plugin stub not found: {:?}", plugin)),
        );
    }

    res.push_str(
        r#"
    data
});"#,
    );

    res
}

fn plugin_stub(plugin: &FlbPlugin) -> Option<String> {
    let section_type = plugin.type_.to_string();
    let PluginInfo {
        label_in_docs,
        doc_path,
    } = PLUGIN_INFO_MAP.get(&PluginKey::new(section_type.clone(), plugin.name.clone()))?;
    // .unwrap_or_else(|| panic!("Plugin info not found for plugin: {:?}", plugin));

    let mut res = String::new();

    res.push_str(&format!(r#"    add_snippet!(data, FlbSectionType::{section_type_enum}, "{label}", "{plugin_name}", "{section_type}/{doc_path}", [
"#,
          section_type_enum = section_type.to_case(Case::Title),
          label = label_in_docs,
          plugin_name = plugin.name,
          section_type = section_type,
          doc_path = doc_path,
    ));

    for prop in plugin.properties.iter() {
        res.push_str(&format!(
            r##"        ("{key}", {default}, r#"{desc}"#),
"##,
            key = prop.name,
            default = prop
                .default
                .as_ref()
                .map(|s| format!(r##"Some(r#"{}"#)"##, s))
                .unwrap_or_else(|| "None".to_owned()),
            desc = prop.description,
        ));
    }

    // TODO:
    // - networking
    // - network_tls

    res.push_str(
        r#"    ]);
"#,
    );

    Some(res)
}
